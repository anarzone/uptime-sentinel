#!/bin/bash

# Pre-push hook for UptimeSentinel
# Runs senior-code-reviewer agent on all files before pushing

# Don't exit on error - we want to handle errors gracefully
# set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
CONFIG_FILE="$(git rev-parse --show-toplevel)/.husky/pre-push-config.yml"
AUTO_REVIEW=true
MAX_FILES=20

# Load configuration if exists
if [ -f "$CONFIG_FILE" ]; then
    # Check for auto_review setting (more robust YAML parsing)
    if grep -E "^auto_review:\s*false" "$CONFIG_FILE" 2>/dev/null; then
        AUTO_REVIEW=false
    fi
    MAX_FILES=$(grep -E "^max_files:\s*[0-9]+" "$CONFIG_FILE" 2>/dev/null | awk '{print $2}' || echo 20)
fi

echo -e "${BLUE}ü§ñ Running pre-push checks...${NC}"
echo ""

# Get the current and remote refs
read local_ref local_sha1 remote_ref remote_sha1

# Check if we're behind remote BEFORE running review
if [ -n "$remote_sha1" ] && [ "$remote_sha1" != "0000000000000000000000000000000000000000" ]; then
    if ! git cat-file -e $remote_sha1 2>/dev/null; then
        echo -e "${YELLOW}‚ö†Ô∏è  Remote has new commits - fetching...${NC}"
        git fetch origin $remote_ref 2>/dev/null || true

        # Check if local is behind remote after fetch
        LOCAL_COMMIT_COUNT=$(git rev-list --count $local_sha1 ^origin/${remote_ref#refs/heads/} 2>/dev/null || echo 0)
        if [ "$LOCAL_COMMIT_COUNT" -gt 0 ]; then
            echo ""
            echo -e "${RED}‚ùå Your branch is behind ${remote_ref#refs/heads/} by $LOCAL_COMMIT_COUNT commit(s)${NC}"
            echo -e "${YELLOW}üí° Run 'git pull' first to update your branch${NC}"
            echo ""
            read -p "Continue anyway? (y/N): " -n 1 -r < /dev/tty
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo -e "${RED}‚ùå Push aborted${NC}"
                exit 1
            fi
        fi
    fi
fi

echo ""
echo -e "${BLUE}ü§ñ Running pre-push code review...${NC}"
echo ""

# Get list of all changed files in this push (including additions, modifications, and deletions)
if [ -z "$remote_sha1" ] || [ "$remote_sha1" = "0000000000000000000000000000000000000000" ]; then
    # New branch or no remote - compare against main
    CHANGED_FILES=$(git diff --name-only --diff-filter=AMD "$(git merge-base $local_sha1 main 2>/dev/null || echo main)" $local_sha1 2>/dev/null || git diff --name-only --diff-filter=AMD $local_sha1)
else
    # Existing branch - remote_sha1 should exist locally now (we fetched above)
    if git cat-file -e $remote_sha1 2>/dev/null; then
        CHANGED_FILES=$(git diff --name-only --diff-filter=AMD ${remote_sha1}..${local_sha1})
    else
        # Fallback: compare against remote tracking branch
        CHANGED_FILES=$(git diff --name-only --diff-filter=AMD origin/${remote_ref#refs/heads/} ${local_sha1} 2>/dev/null || git diff --name-only --diff-filter=AMD $local_sha1)
    fi
fi

# Count all changed files
FILE_COUNT=0
if [ -n "$CHANGED_FILES" ]; then
    FILE_COUNT=$(echo "$CHANGED_FILES" | grep -v -e '^[[:space:]]*$' | wc -l | tr -d '[:space:]')
fi

# Check if auto-review is enabled
if [ "$AUTO_REVIEW" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Automatic code review disabled (skipping)${NC}"
    echo -e "${YELLOW}   Pre-commit hook already ran composer checks ‚úÖ${NC}"
    exit 0
fi

if [ "$FILE_COUNT" -eq 0 ]; then
    echo -e "${GREEN}‚úÖ No files changed - skipping code review${NC}"
    exit 0
fi

if [ "$FILE_COUNT" -gt "$MAX_FILES" ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  $FILE_COUNT files changed (max: $MAX_FILES) - skipping automatic review${NC}"
    echo -e "${YELLOW}   Large changes should be reviewed via PR workflow instead${NC}"
    exit 0
fi

echo -e "${BLUE}üìù Reviewing $FILE_COUNT file(s):${NC}"
echo "$CHANGED_FILES" | while read -r file; do
    [ -n "$file" ] && echo -e "${BLUE}   - $file${NC}"
done
echo ""

# Create temp file for review output
REVIEW_OUTPUT=$(mktemp)
trap "rm -f $REVIEW_OUTPUT" EXIT

# Run the review using Claude Code CLI
echo -e "${BLUE}ü§ñ Calling Claude Code senior-code-reviewer agent...${NC}"

# Check if claude CLI is available
if ! command -v claude &> /dev/null; then
    echo -e "${RED}‚ùå claude CLI not found${NC}"
    echo -e "${RED}   Automatic review requires the Claude CLI to be installed${NC}"
    echo ""
    echo -e "${YELLOW}üí° Install from: https://code.claude.com${NC}"
    echo -e "${YELLOW}   Or disable auto_review in .husky/pre-push-config.yml${NC}"
    echo ""
    echo -e "${YELLOW}üí° To bypass this check: git push --no-verify${NC}"
    exit 1
fi

if claude ask > "$REVIEW_OUTPUT" 2>&1 <<EOF
You are a strict code reviewer reviewing changes BEFORE they are pushed. You must make a binary decision.

**Files to review**:
$(echo "$CHANGED_FILES" | while read -r file; do
    [ -n "$file" ] && echo "- $file"
done)

**Your task**: Review comprehensively and decide:
1. Start with "BLOCKING ISSUES FOUND:" if ANY issues exist (typo, bug, security, style, architecture, performance, etc.)
2. Start with "APPROVED:" ONLY if code is perfect and ready to merge

**Review criteria** (ANY issue means BLOCKING):
- **YAML**: Syntax errors, invalid keys, typos, wrong indentation, missing required fields
- **Security**: Secrets exposed, injection vulnerabilities, missing validation
- **Code Quality**: Style violations, missing types, unclear naming, complexity
- **Architecture**: DDD violations, wrong patterns, scalability concerns
- **Configuration**: Wrong values, environment-specific issues, missing settings
- **Documentation**: Incomplete, unclear, or inaccurate docs

**Output format**:
```
BLOCKING ISSUES FOUND:

1. [Issue title] (file:line)
   [Why it's blocking]

OR

APPROVED: No issues found. Code is ready to merge.
```

**Be strict**. If unsure, mark as BLOCKING. Better to over-review than let bugs through.
EOF
then
    REVIEW_SUCCESS=true
else
    REVIEW_SUCCESS=false
fi

# Display review output (with nice formatting)
echo ""
echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
echo -e "${BLUE}üìä CODE REVIEW RESULTS${NC}"
echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
echo ""
cat "$REVIEW_OUTPUT"
echo ""
echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
echo ""

# Interactive prompt after review
if grep -q "BLOCKING ISSUES FOUND:" "$REVIEW_OUTPUT"; then
    echo ""
    echo -e "${RED}‚ö†Ô∏è  ISSUES FOUND - Review blocked${NC}"
    echo -e "${YELLOW}‚ö†Ô∏è  You must fix these issues before pushing${NC}"
    echo ""
    # Read from terminal to avoid issues with git's stdin redirection
    read -p "Continue anyway despite issues? (y/N): " -n 1 -r < /dev/tty
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo -e "${RED}‚ùå Push aborted - fix issues and try again${NC}"
        echo ""
        echo -e "${YELLOW}üí° To bypass: git push --no-verify${NC}"
        exit 1
    fi
    echo -e "${YELLOW}‚ö†Ô∏è  Proceeding with push despite issues...${NC}"
elif grep -q "APPROVED:" "$REVIEW_OUTPUT"; then
    echo ""
    echo -e "${GREEN}‚úÖ Code review passed - no issues found!${NC}"
else
    echo ""
    echo -e "${YELLOW}‚ö†Ô∏è  Review output unclear - treating as blocking${NC}"
    echo -e "${YELLOW}‚ö†Ô∏è  (Expected 'APPROVED:' or 'BLOCKING ISSUES FOUND:')${NC}"
    echo ""
    read -p "Continue anyway? (y/N): " -n 1 -r < /dev/tty
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo -e "${RED}‚ùå Push aborted${NC}"
        exit 1
    fi
fi

echo ""
echo -e "${GREEN}üöÄ Proceeding with push...${NC}"
exit 0