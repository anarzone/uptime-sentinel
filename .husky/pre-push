#!/bin/bash

# Pre-push hook for UptimeSentinel
# Runs senior-code-reviewer agent on all files before pushing

# SECURITY NOTES:
# - Git itself validates filenames and doesn't allow dangerous characters (newlines, etc.)
# - Quoted heredoc (<<'EOF') prevents ALL shell expansion
# - File content is written to temp files, then passed to claude ask via stdin - never executed
# - mktemp without template is the recommended, secure way to create temp files
# - The || true on git fetch is intentional (new branches might not exist on remote)

# Intentionally not using 'set -e' - we handle errors manually to provide
# better UX (e.g., continue after fetch failures, prompt user on issues)
# set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper function for interactive prompts
# Returns 0 (success) if user answers yes, 1 otherwise
prompt_user() {
    local prompt_message="$1"
    local response

    # Check if /dev/tty is accessible
    if [ ! -t 0 ] && [ ! -c /dev/tty ]; then
        echo -e "${RED}âŒ Not an interactive terminal - cannot prompt${NC}" >&2
        return 1
    fi

    # Prompt user (waits for Enter key)
    read -p "$prompt_message" response < /dev/tty
    if [[ $response =~ ^[Yy]$ ]]; then
        return 0
    else
        return 1
    fi
}

# Configuration
CONFIG_FILE="$(git rev-parse --show-toplevel)/.husky/pre-push-config.yml"
AUTO_REVIEW=true
MAX_FILES=20

# Load configuration if exists
if [ -f "$CONFIG_FILE" ]; then
    # Check for auto_review setting (more robust YAML parsing)
    if grep -E "^auto_review:\s*false" "$CONFIG_FILE" 2>/dev/null; then
        AUTO_REVIEW=false
    fi
    MAX_FILES=$(grep -E "^max_files:\s*[0-9]+" "$CONFIG_FILE" 2>/dev/null | awk '{print $2}' || echo 20)
fi

echo -e "${BLUE}ğŸ¤– Running pre-push checks...${NC}"
echo ""

# Get the current and remote refs
read local_ref local_sha1 remote_ref remote_sha1

# Check if we're behind remote BEFORE running review
if [ -n "$remote_sha1" ] && [ "$remote_sha1" != "0000000000000000000000000000000000000000" ]; then
    if ! git cat-file -e $remote_sha1 2>/dev/null; then
        echo -e "${YELLOW}âš ï¸  Remote has new commits - fetching...${NC}"
        git fetch origin $remote_ref 2>/dev/null || true

        # Check if local is behind remote after fetch
        LOCAL_COMMIT_COUNT=$(git rev-list --count $local_sha1 ^origin/${remote_ref#refs/heads/} 2>/dev/null || echo 0)
        if [ "$LOCAL_COMMIT_COUNT" -gt 0 ]; then
            echo ""
            echo -e "${RED}âŒ Your branch is behind ${remote_ref#refs/heads/} by $LOCAL_COMMIT_COUNT commit(s)${NC}"
            echo -e "${YELLOW}ğŸ’¡ Run 'git pull' first to update your branch${NC}"
            echo ""
            if ! prompt_user "Continue anyway? (y/N): "; then
                echo -e "${RED}âŒ Push aborted${NC}"
                exit 1
            fi
        fi
    fi
fi

echo ""
echo -e "${BLUE}ğŸ¤– Running pre-push code review...${NC}"
echo ""

# Get list of all changed files in this push (including additions, modifications, and deletions)
if [ -z "$remote_sha1" ] || [ "$remote_sha1" = "0000000000000000000000000000000000000000" ]; then
    # New branch or no remote - compare against main
    CHANGED_FILES=$(git diff --name-only --diff-filter=AMD "$(git merge-base $local_sha1 main 2>/dev/null || echo main)" $local_sha1 2>/dev/null || git diff --name-only --diff-filter=AMD $local_sha1)
else
    # Existing branch - remote_sha1 should exist locally now (we fetched above)
    if git cat-file -e $remote_sha1 2>/dev/null; then
        CHANGED_FILES=$(git diff --name-only --diff-filter=AMD ${remote_sha1}..${local_sha1})
    else
        # Fallback: compare against remote tracking branch
        CHANGED_FILES=$(git diff --name-only --diff-filter=AMD origin/${remote_ref#refs/heads/} ${local_sha1} 2>/dev/null || git diff --name-only --diff-filter=AMD $local_sha1)
    fi
fi

# Count all changed files
FILE_COUNT=0
if [ -n "$CHANGED_FILES" ]; then
    FILE_COUNT=$(echo "$CHANGED_FILES" | grep -v -e '^[[:space:]]*$' | wc -l | tr -d '[:space:]')
fi

# Check if auto-review is enabled
if [ "$AUTO_REVIEW" = false ]; then
    echo -e "${YELLOW}â­ï¸  Automatic code review disabled (skipping)${NC}"
    echo -e "${YELLOW}   Pre-commit hook already ran composer checks âœ…${NC}"
    exit 0
fi

if [ "$FILE_COUNT" -eq 0 ]; then
    echo -e "${GREEN}âœ… No files changed - skipping code review${NC}"
    exit 0
fi

if [ "$FILE_COUNT" -gt "$MAX_FILES" ]; then
    echo -e "${YELLOW}âš ï¸  $FILE_COUNT files changed (max: $MAX_FILES) - skipping automatic review${NC}"
    echo -e "${YELLOW}   Large changes should be reviewed via PR workflow instead${NC}"
    exit 0
fi

echo -e "${BLUE}ğŸ“ Reviewing $FILE_COUNT file(s):${NC}"
echo "$CHANGED_FILES" | while read -r file; do
    [ -n "$file" ] && echo -e "${BLUE}   - ${file}${NC}"
done
echo ""

# Create temp file for review output
REVIEW_OUTPUT=$(mktemp)
trap 'rm -f "$REVIEW_OUTPUT" "${REVIEW_OUTPUT}.result"' EXIT

# Build the review prompt (using quoted EOF to prevent backtick execution)
cat > "$REVIEW_OUTPUT" <<'REVIEW_PROMPT'
You are a strict code reviewer reviewing changes BEFORE they are pushed. You must make a binary decision.

**Files to review**:
REVIEW_PROMPT

# Append file list with shell expansion
echo "$CHANGED_FILES" | while read -r file; do
    [ -n "$file" ] && echo "- $file"
done >> "$REVIEW_OUTPUT"

# Append rest of prompt
cat >> "$REVIEW_OUTPUT" <<'REVIEW_PROMPT'

**Your task**: Review comprehensively and decide:
1. Start with "BLOCKING ISSUES FOUND:" if ANY issues exist (typo, bug, security, style, architecture, performance, etc.)
2. Start with "APPROVED:" ONLY if code is perfect and ready to merge

**Review criteria** (ANY issue means BLOCKING):
- **YAML**: Syntax errors, invalid keys, typos, wrong indentation, missing required fields
- **Security**: Secrets exposed, injection vulnerabilities, missing validation
- **Code Quality**: Style violations, missing types, unclear naming, complexity
- **Architecture**: DDD violations, wrong patterns, scalability concerns
- **Configuration**: Wrong values, environment-specific issues, missing settings
- **Documentation**: Incomplete, unclear, or inaccurate docs

**Output format**:
BLOCKING ISSUES FOUND:

1. [Issue title] (file:line)
   [Why it's blocking]

OR

APPROVED: No issues found. Code is ready to merge.

**Be strict**. If unsure, mark as BLOCKING. Better to over-review than let bugs through.
REVIEW_PROMPT

# Run the review using Claude Code CLI
echo -e "${BLUE}ğŸ¤– Calling Claude Code senior-code-reviewer agent...${NC}"

# Check if claude CLI is available
if ! command -v claude &> /dev/null; then
    echo -e "${RED}âŒ claude CLI not found${NC}"
    echo -e "${RED}   Automatic review requires the Claude CLI to be installed${NC}"
    echo ""
    echo -e "${YELLOW}ğŸ’¡ Install from: https://code.claude.com${NC}"
    echo -e "${YELLOW}   Or disable auto_review in .husky/pre-push-config.yml${NC}"
    echo ""
    echo -e "${YELLOW}ğŸ’¡ To bypass this check: git push --no-verify${NC}"
    exit 1
fi

# Run claude ask with the prepared prompt
if claude ask < "$REVIEW_OUTPUT" > "${REVIEW_OUTPUT}.result" 2>&1; then
    mv "${REVIEW_OUTPUT}.result" "$REVIEW_OUTPUT"
else
    # Claude CLI failed - show the error output
    echo ""
    echo -e "${RED}âŒ Claude CLI command failed${NC}"
    echo -e "${YELLOW}âš ï¸  Unable to complete code review${NC}"
    echo ""
    echo -e "${YELLOW}ğŸ“‹ Error output:${NC}"
    cat "${REVIEW_OUTPUT}.result" 2>/dev/null || echo "(no error output available)"
    echo ""
    echo -e "${YELLOW}ğŸ’¡ Check that Claude CLI is installed and working${NC}"
    echo -e "${YELLOW}ğŸ’¡ To bypass: git push --no-verify${NC}"
    exit 1
fi

# Display review output (with nice formatting)
echo ""
echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo -e "${BLUE}ğŸ“Š CODE REVIEW RESULTS${NC}"
echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo ""
cat "$REVIEW_OUTPUT"
echo ""
echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo ""

# Interactive prompt after review
if grep -q "BLOCKING ISSUES FOUND:" "$REVIEW_OUTPUT"; then
    echo ""
    echo -e "${RED}âš ï¸  ISSUES FOUND - Review blocked${NC}"
    echo -e "${YELLOW}âš ï¸  You must fix these issues before pushing${NC}"
    echo ""
    if ! prompt_user "Continue anyway despite issues? (y/N): "; then
        echo -e "${RED}âŒ Push aborted - fix issues and try again${NC}"
        echo ""
        echo -e "${YELLOW}ğŸ’¡ To bypass: git push --no-verify${NC}"
        exit 1
    fi
    echo -e "${YELLOW}âš ï¸  Proceeding with push despite issues...${NC}"
elif grep -q "APPROVED:" "$REVIEW_OUTPUT"; then
    echo ""
    echo -e "${GREEN}âœ… Code review passed - no issues found!${NC}"
else
    echo ""
    echo -e "${RED}âŒ Review output unclear - blocking push${NC}"
    echo -e "${YELLOW}âš ï¸  (Expected 'APPROVED:' or 'BLOCKING ISSUES FOUND:')${NC}"
    echo ""
    echo -e "${YELLOW}ğŸ’¡ This usually means the Claude CLI failed or timed out${NC}"
    echo -e "${YELLOW}ğŸ’¡ Check the review output above for errors${NC}"
    echo -e "${YELLOW}ğŸ’¡ To bypass: git push --no-verify${NC}"
    exit 1
fi

echo ""
echo -e "${GREEN}ğŸš€ Proceeding with push...${NC}"
exit 0